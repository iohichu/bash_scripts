Sergejs Ponomarenko - Disrupting the perfect integrity of the initial file with this vile addition.

Напишите скрипт, который выполнит:
1 Запишет в файл test.log имя пользователя, под которым вы работаете в системе. Файл должен располагаться в /home/user/test/logs (вывод имени должен быть написан как: your name is: )
2 Допишет в файл информацию из файла readme.txt из папки /root (но только предпоследнюю строку)
3 Добавит в файл дату (только дату)
4 Создаст 8 файлов с названием от b до i  по пути /tmp/files/drIVE с расширением txt
5 Выведет на экран слово DONE
Ivan
________________________________

#!/bin/bash
mkdir -p /home/user/test/logs
echo "your name is: $(whoami)" > /home/user/test/logs/test.log
cat /root/readme.txt | tail -2 | head -1 >> /home/user/test/logs/test.log
date '+%D' >> /home/user/test/logs/test.log
mkdir -p /tmp/files/drIVE/
        for i in {b..i}
        do
        touch /tmp/files/drIVE/$i.txt
        done
 
echo "DONE"


________________________________


Сделайте скрипт, который выполнит:
1 Создаст файл в пути /tmp/test/my/linux c названием file.txt
2 запишет в него информацию (строку) из вывода команды df -h о корневом разделе
3 допишет в него полную информацию о файлах\папках из домашней директории (включая скрытые)
4 напишет из какой папки вы работаете (выведет рабочую папку на экран)
5 допишет в файл слово “done”

*сделать файл программой по умолчанию с запуском по вашему имени

#!/bin/bash
 
mkdir -p /tmp/test/my/linux
df -h | grep -w / >> /tmp/test/my/linux/file.txt
ls -la /root >> /tmp/test/my/linux/file.txt
pwd
echo "done" >> /tmp/test/my/linux/file.txt
________________________________



Напишите скрипт на bash, который выполнит:
1 Выведет слово старт слово “script start”
2 Используя цикл создаст три файла с названием сегодняшней даты (каждый файл должен отличаться _цифра в конце)
3 - В первый файл добавит вывод команды df -h (информация о корневом разделе)
   - Во второй файл добавит слово Logs: и вывод из команды netstat
   - В третий добавит информацию о багах из файла /proc/cpuinfo
4 Выведет на экран слово “done”

#!/bin/bash

# Вывод "script start"
echo "script start"

# Создание трех файлов с сегодняшней датой и цифрой в конце

date_today=$(date +"%Y-%m-%d")
file1="${date_today}_1"
file2="${date_today}_2"
file3="${date_today}_3"
# В первый файл добавление вывода df -h
df -h > "$file1"

# Во второй файл добавление "Logs:" и вывода из команды netstat
echo "Logs:" > "$file2"
netstat >> "$file2"

# В третий файл добавление информации о багах из файла /proc/cpuinfo
cat /proc/cpuinfo | grep -w bugs  > "$file3"
# Вывод "done"
echo "done"


__________________________

Напишите файл скрипта, который выполнит:
1 Создаст 5 файлов с названием от a до e
 * файлы должны попасть в папку /opt/a_e
2 - добавит в файл a сколько процентов занято в корневом разделе
   - добавит в файл b фразу “i’m file b”
   - добавит в файл c информацию о подключеных процессах по ssh
   - запишет в файл d сегодняшнюю дату
   - добавит в файл e вывод из файла /etc/group (вторую строку)
3 Выведет на экран “done” 
  *уложитесь в 340 символов
  ** файлы делать через цикл (=


#!/bin/bash
mkdir -p /opt/a_e
for i in {a..e}
do
touch /opt/a_e/$i
done
df -h | grep -w / | awk '{print $5}' >> /opt/a_e/a
echo “i’m file b" >> /opt/a_e/b
ps -ef | grep ssh >> /opt/a_e/c
date +’%D’ > /opt/a_e/d
cat /etc/group | head -2 | tail -1 >> /opt/a_e/e
echo “done”

_________________________

Сделайте файл скрипта, который выполнит:
1 Выведет на экран дату и время
2 напишет “test start” на экране
3 дозапишет в файл logs.log фразу “test passed:”
 * файл должен быть расположен в /etc/drive/testlogs
4 дозапишет в файл logs.log текущее время
5 дозапишет в файл logs.log вывод из файла /opt/temu/root-x86.cfg (стоки с 3-й по 5-ую)
6 Переместит файл logs.log в новый путь /tmp/new
7 выведет на экран “done”

#!/bin/bash
date +'%D/%T'
echo "test start"
mkdir -p /etc/drive/testlogs
echo "test passed:" >> /etc/drive/testlogs/logs.log
date +'%T' >> /etc/drive/testlogs/logs.log
cat /opt/temu/root-x86.cfg | sed -n '3,5p' >> /etc/drive/testlogs/logs.log
mkdir -p /tmp/new
mv /etc/drive/testlogs/logs.log /tmp/new
echo "done"


_______________________

Создайте файл сценария на bash, который будет пинговать 8.8.8.8 десять раз каждые три минуты (после десяти раз нужно сделать разделение строкой, в которой будет написано время и дата:) и отправлять полученные данные в файл ping.log по пути /logs
*скрипт должен работать в фоновом режиме

#!/bin/bash
mkdir -p /logs
while true; do
ping -c 10 8.8.8.8 >> /logs/ping.log
echo "time: $(date +'%T_%D')" >> /logs/ping.log
sleep 180
done &

* 		mkdir -p /logs: Создает каталог /logs с опцией -p, которая позволяет создать каталог, если он не существует.
* 		while true; do: Начинает бесконечный цикл для выполнения пинга.
* 		ping -c 10 8.8.8.8 >> /logs/ping.log: Выполняет пинг на IP-адрес 8.8.8.8 с 10 попытками (-c 10) и добавляет результат в файл лога
* 		echo "Время: $(date)" >> /logs/ping.log: Добавляет разделитель с текущим временем в файл лога с помощью команды date.
* 		sleep 180: Задерживает выполнение скрипта на 180 секунд (3 минуты) перед началом следующей итерации цикла.
* 		&: Запускает скрипт в фоновом режиме, что позволяет вам продолжить работу в том же терминале без ожидания завершения скрипта.


___________________________

Напишите файл сценария на баш, который будет проверять значение в процентах (насколько занят корневой раздел, используя команду df -h). Если значение превышает 90%, то необходимо писать емейл на адрес test@test.com со словами “места мало, блин!”
Скрипт должен запускаться каждые 15 минут в фоновом режиме

#!/bin/bash

# Бесконечный цикл для мониторинга каждые 15 минут
while true; do
    # Запускаем df -h и фильтруем вывод, чтобы получить процент использования корневого раздела
    usage_percentage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')

    # Устанавливаем пороговое значение для предупреждения (90%)
    threshold=90

    # Проверяем, превышает ли использование пороговое значение
    if [ "$usage_percentage" -gt "$threshold" ]; then
        # Если превышено, отправляем электронное письмо
        echo "места мало, блин!" | mail -s "Предупреждение о заполнении корневого раздела" test@test.com
    fi

    # Ждем 15 минут перед следующей проверкой
    sleep 900
done &

Что делают команды и ключи:
* 		while true; do: Начинает бесконечный цикл для мониторинга каждые 15 минут.
* 		df -h /: Выполняет команду df для мониторинга использования корневого раздела. -h означает использование удобного для чтения формата.
* 		awk 'NR==2 {print $5}': Фильтрует вывод df и извлекает процент использования корневого раздела (вторая строка, пятый столбец).
* 		sed 's/%//': Удаляет символ процента из полученного процента, чтобы получить только числовое значение.
* 		threshold=90: Устанавливает пороговое значение в 90%.
* 		if [ "$usage_percentage" -gt "$threshold" ]; then: Проверяет, превышает ли использование пороговое значение.
* 		echo "места мало, блин!" | mail -s "Предупреждение о заполнении корневого раздела" test@test.com: Если использование превышает порог, отправляет электронное письмо с указанным сообщением и темой на адрес test@test.com с использованием mail.
* 		sleep 900: Задерживает выполнение скрипта на 900 секунд (15 минут) перед началом следующей итерации цикла.
* 		&: Запускает скрипт в фоновом режиме, что позволяет ему работать в фоне без блокировки терминала.


___________________________



